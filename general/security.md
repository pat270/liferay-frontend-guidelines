# Security

## Dependabot

[Dependabot](https://dependabot.com/) is a [GitHub-owned](https://dependabot.com/blog/hello-github/) bot that sends pull requests (such as [this example PR](https://github.com/liferay/liferay-frontend-guidelines/pull/126)) updating dependencies containing potential vulnerabilities to newer versions.

> Our general policy on these pulls is **not to merge** them but rather take them as a cue that we should review the dependency and perform a manual update at an appropriate time, if required.

Rationale:

-   Lockfile-only changes are opaque (hard to understand) and brittle (easily reverted, perhaps by accident, when running package manager commands). The place to make an explicit _declaration_ of what versions of dependencies you wish to use in a project is the `package.json` file.
-   Lockfile-only changes provide a false sense of security because they affect only the local development environment of people working in the repository: the actual consumers of the NPM packages install dependencies based on the version ranges declared in the `package.json`, combined with the dependency resolution logic implemented by their package manager (`npm`, `yarn` etc); the lockfile is not included in the package itself. The outcome of the dependency resolution algorithm is unpredictable because it depends on which package manager is used (and which version!), and is time-sensitive (in the sense that it depends on the mutable contents of the package registry at the time of execution).
-   The way to truly force the outcome of dependency resolution, in the event that that can't be achieved via version ranges in `package.json` is to use a `resolutions` field (often, this is required by transitive dependencies, especially if there are multiple conflicting or ambiguous requirements for a given package), but note that even this isn't ideal because it depends on the use of a specific package manager (Yarn), and really only works at the application level (ie. the consumer of a package) and not at the library level. As such, the preferred method of moving to a newer version of a transitive dependency is to update the other dependencies responsible for bringing it in in the first place. This may entail a delay, but see the next point for why updates may not be so urgent.
-   The impact of "security vulnerabilities" can only be determined with careful evaluation. For example, the "vulnerable" package in question might pose no risk at all if it is only installed in the development environment and is never exposed to any untrusted input. In the example PR linked to above, for instance, `yarn why` shows that [acorn](https://www.npmjs.com/package/acorn) is being used as a transitive dependency of [ESLint](https://www.npmjs.com/package/eslint), which is only used in development. A malicious PR seeking to exploit this vulnerability would, at most, run in the sandboxed environment of [Travis CI](https://travis-ci.org/github/liferay) or [GitHub Actions](https://github.com/features/actions).
-   In addition to requiring manual review in order to assess actual security impact, manual review is also required in order to evaluate the risk of regressions. Automated updates are only safe if affected packages in the dependency graph actually employ [SemVer](https://semver.org/) correctly, but that can't be guaranteed unless we can exclude the possibility of human error, which we obviously can't.
-   The need for (potentially costly) human review means that the only efficient way to deal with these updates is to batch them; the cost of manually reviewing and QA-ing pull requests as they arrive is too high. (Note: this is not an argument for totally _ignoring_ the Dependabot pull requests; we still need to do some immediate triage on these things as they arrive to determine whether or not there is an actually critical vulnerability at play which would necessitate an immediate update and release.)
